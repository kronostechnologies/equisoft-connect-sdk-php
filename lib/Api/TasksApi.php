<?php
/**
 * TasksApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Equisoft\SDK\EquisoftConnect
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Equisoft /connect API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0-equisoft1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Equisoft\SDK\EquisoftConnect\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Equisoft\SDK\EquisoftConnect\ApiException;
use Equisoft\SDK\EquisoftConnect\Configuration;
use Equisoft\SDK\EquisoftConnect\HeaderSelector;
use Equisoft\SDK\EquisoftConnect\ObjectSerializer;

/**
 * TasksApi Class Doc Comment
 *
 * @category Class
 * @package  Equisoft\SDK\EquisoftConnect
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TasksApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'archiveTaskInternalNote' => [
            'application/json',
        ],
        'createTask' => [
            'application/json',
        ],
        'createTaskInternalNote' => [
            'application/json',
        ],
        'deleteTask' => [
            'application/json',
        ],
        'deleteTasks' => [
            'application/json',
        ],
        'getTask' => [
            'application/json',
        ],
        'getTaskInternalNoteList' => [
            'application/json',
        ],
        'listTasks' => [
            'application/json',
        ],
        'patchTask' => [
            'application/json',
        ],
        'patchTaskInternalNote' => [
            'application/json',
        ],
        'putTaskLinksDocuments' => [
            'application/json',
        ],
        'restoreTaskInternalNote' => [
            'application/json',
        ],
        'transferTaskToCompleted' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation archiveTaskInternalNote
     *
     * Archive an internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function archiveTaskInternalNote($taskId, $noteId, $acceptLanguage = null, string $contentType = self::contentTypes['archiveTaskInternalNote'][0])
    {
        $this->archiveTaskInternalNoteWithHttpInfo($taskId, $noteId, $acceptLanguage, $contentType);
    }

    /**
     * Operation archiveTaskInternalNoteWithHttpInfo
     *
     * Archive an internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function archiveTaskInternalNoteWithHttpInfo($taskId, $noteId, $acceptLanguage = null, string $contentType = self::contentTypes['archiveTaskInternalNote'][0])
    {
        $request = $this->archiveTaskInternalNoteRequest($taskId, $noteId, $acceptLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation archiveTaskInternalNoteAsync
     *
     * Archive an internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function archiveTaskInternalNoteAsync($taskId, $noteId, $acceptLanguage = null, string $contentType = self::contentTypes['archiveTaskInternalNote'][0])
    {
        return $this->archiveTaskInternalNoteAsyncWithHttpInfo($taskId, $noteId, $acceptLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation archiveTaskInternalNoteAsyncWithHttpInfo
     *
     * Archive an internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function archiveTaskInternalNoteAsyncWithHttpInfo($taskId, $noteId, $acceptLanguage = null, string $contentType = self::contentTypes['archiveTaskInternalNote'][0])
    {
        $returnType = '';
        $request = $this->archiveTaskInternalNoteRequest($taskId, $noteId, $acceptLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'archiveTaskInternalNote'
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function archiveTaskInternalNoteRequest($taskId, $noteId, $acceptLanguage = null, string $contentType = self::contentTypes['archiveTaskInternalNote'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling archiveTaskInternalNote'
            );
        }

        // verify the required parameter 'noteId' is set
        if ($noteId === null || (is_array($noteId) && count($noteId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $noteId when calling archiveTaskInternalNote'
            );
        }



        $resourcePath = '/crm/api/v1/tasks/{taskId}/notes/{noteId}/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }

        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }
        // path params
        if ($noteId !== null) {
            $resourcePath = str_replace(
                '{' . 'noteId' . '}',
                ObjectSerializer::toPathValue($noteId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTask
     *
     * Create a task.
     *
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskPayload $tasksCreateTaskPayload tasksCreateTaskPayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTask'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse
     */
    public function createTask($tasksCreateTaskPayload, $acceptLanguage = null, string $contentType = self::contentTypes['createTask'][0])
    {
        list($response) = $this->createTaskWithHttpInfo($tasksCreateTaskPayload, $acceptLanguage, $contentType);
        return $response;
    }

    /**
     * Operation createTaskWithHttpInfo
     *
     * Create a task.
     *
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskPayload $tasksCreateTaskPayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTask'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaskWithHttpInfo($tasksCreateTaskPayload, $acceptLanguage = null, string $contentType = self::contentTypes['createTask'][0])
    {
        $request = $this->createTaskRequest($tasksCreateTaskPayload, $acceptLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTaskAsync
     *
     * Create a task.
     *
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskPayload $tasksCreateTaskPayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskAsync($tasksCreateTaskPayload, $acceptLanguage = null, string $contentType = self::contentTypes['createTask'][0])
    {
        return $this->createTaskAsyncWithHttpInfo($tasksCreateTaskPayload, $acceptLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaskAsyncWithHttpInfo
     *
     * Create a task.
     *
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskPayload $tasksCreateTaskPayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskAsyncWithHttpInfo($tasksCreateTaskPayload, $acceptLanguage = null, string $contentType = self::contentTypes['createTask'][0])
    {
        $returnType = '\Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskResponse';
        $request = $this->createTaskRequest($tasksCreateTaskPayload, $acceptLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTask'
     *
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksCreateTaskPayload $tasksCreateTaskPayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTaskRequest($tasksCreateTaskPayload, $acceptLanguage = null, string $contentType = self::contentTypes['createTask'][0])
    {

        // verify the required parameter 'tasksCreateTaskPayload' is set
        if ($tasksCreateTaskPayload === null || (is_array($tasksCreateTaskPayload) && count($tasksCreateTaskPayload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tasksCreateTaskPayload when calling createTask'
            );
        }



        $resourcePath = '/crm/api/v1/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tasksCreateTaskPayload)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tasksCreateTaskPayload));
            } else {
                $httpBody = $tasksCreateTaskPayload;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTaskInternalNote
     *
     * Add an internal note to a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNotePayload $internalNotesCreateNotePayload internalNotesCreateNotePayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNoteResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse
     */
    public function createTaskInternalNote($taskId, $internalNotesCreateNotePayload, $acceptLanguage = null, string $contentType = self::contentTypes['createTaskInternalNote'][0])
    {
        list($response) = $this->createTaskInternalNoteWithHttpInfo($taskId, $internalNotesCreateNotePayload, $acceptLanguage, $contentType);
        return $response;
    }

    /**
     * Operation createTaskInternalNoteWithHttpInfo
     *
     * Add an internal note to a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNotePayload $internalNotesCreateNotePayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNoteResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaskInternalNoteWithHttpInfo($taskId, $internalNotesCreateNotePayload, $acceptLanguage = null, string $contentType = self::contentTypes['createTaskInternalNote'][0])
    {
        $request = $this->createTaskInternalNoteRequest($taskId, $internalNotesCreateNotePayload, $acceptLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNoteResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNoteResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNoteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTaskInternalNoteAsync
     *
     * Add an internal note to a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNotePayload $internalNotesCreateNotePayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskInternalNoteAsync($taskId, $internalNotesCreateNotePayload, $acceptLanguage = null, string $contentType = self::contentTypes['createTaskInternalNote'][0])
    {
        return $this->createTaskInternalNoteAsyncWithHttpInfo($taskId, $internalNotesCreateNotePayload, $acceptLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaskInternalNoteAsyncWithHttpInfo
     *
     * Add an internal note to a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNotePayload $internalNotesCreateNotePayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskInternalNoteAsyncWithHttpInfo($taskId, $internalNotesCreateNotePayload, $acceptLanguage = null, string $contentType = self::contentTypes['createTaskInternalNote'][0])
    {
        $returnType = '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNoteResponse';
        $request = $this->createTaskInternalNoteRequest($taskId, $internalNotesCreateNotePayload, $acceptLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTaskInternalNote'
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesCreateNotePayload $internalNotesCreateNotePayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTaskInternalNoteRequest($taskId, $internalNotesCreateNotePayload, $acceptLanguage = null, string $contentType = self::contentTypes['createTaskInternalNote'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling createTaskInternalNote'
            );
        }

        // verify the required parameter 'internalNotesCreateNotePayload' is set
        if ($internalNotesCreateNotePayload === null || (is_array($internalNotesCreateNotePayload) && count($internalNotesCreateNotePayload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internalNotesCreateNotePayload when calling createTaskInternalNote'
            );
        }



        $resourcePath = '/crm/api/v1/tasks/{taskId}/notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }

        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($internalNotesCreateNotePayload)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($internalNotesCreateNotePayload));
            } else {
                $httpBody = $internalNotesCreateNotePayload;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTask
     *
     * Delete a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTask'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTask($taskId, string $contentType = self::contentTypes['deleteTask'][0])
    {
        $this->deleteTaskWithHttpInfo($taskId, $contentType);
    }

    /**
     * Operation deleteTaskWithHttpInfo
     *
     * Delete a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTask'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTaskWithHttpInfo($taskId, string $contentType = self::contentTypes['deleteTask'][0])
    {
        $request = $this->deleteTaskRequest($taskId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTaskAsync
     *
     * Delete a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskAsync($taskId, string $contentType = self::contentTypes['deleteTask'][0])
    {
        return $this->deleteTaskAsyncWithHttpInfo($taskId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTaskAsyncWithHttpInfo
     *
     * Delete a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskAsyncWithHttpInfo($taskId, string $contentType = self::contentTypes['deleteTask'][0])
    {
        $returnType = '';
        $request = $this->deleteTaskRequest($taskId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTask'
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTaskRequest($taskId, string $contentType = self::contentTypes['deleteTask'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling deleteTask'
            );
        }


        $resourcePath = '/crm/api/v1/tasks/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTasks
     *
     * Delete some tasks.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTasks'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTasks(string $contentType = self::contentTypes['deleteTasks'][0])
    {
        $this->deleteTasksWithHttpInfo($contentType);
    }

    /**
     * Operation deleteTasksWithHttpInfo
     *
     * Delete some tasks.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTasks'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTasksWithHttpInfo(string $contentType = self::contentTypes['deleteTasks'][0])
    {
        $request = $this->deleteTasksRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTasksAsync
     *
     * Delete some tasks.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTasksAsync(string $contentType = self::contentTypes['deleteTasks'][0])
    {
        return $this->deleteTasksAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTasksAsyncWithHttpInfo
     *
     * Delete some tasks.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTasksAsyncWithHttpInfo(string $contentType = self::contentTypes['deleteTasks'][0])
    {
        $returnType = '';
        $request = $this->deleteTasksRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTasks'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTasksRequest(string $contentType = self::contentTypes['deleteTasks'][0])
    {


        $resourcePath = '/crm/api/v1/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTask
     *
     * Return the detail of a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTask'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Equisoft\SDK\EquisoftConnect\Model\TasksTask|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse
     */
    public function getTask($taskId, $acceptLanguage = null, string $contentType = self::contentTypes['getTask'][0])
    {
        list($response) = $this->getTaskWithHttpInfo($taskId, $acceptLanguage, $contentType);
        return $response;
    }

    /**
     * Operation getTaskWithHttpInfo
     *
     * Return the detail of a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTask'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Equisoft\SDK\EquisoftConnect\Model\TasksTask|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaskWithHttpInfo($taskId, $acceptLanguage = null, string $contentType = self::contentTypes['getTask'][0])
    {
        $request = $this->getTaskRequest($taskId, $acceptLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\TasksTask',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Equisoft\SDK\EquisoftConnect\Model\TasksTask',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\TasksTask',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTaskAsync
     *
     * Return the detail of a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskAsync($taskId, $acceptLanguage = null, string $contentType = self::contentTypes['getTask'][0])
    {
        return $this->getTaskAsyncWithHttpInfo($taskId, $acceptLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskAsyncWithHttpInfo
     *
     * Return the detail of a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskAsyncWithHttpInfo($taskId, $acceptLanguage = null, string $contentType = self::contentTypes['getTask'][0])
    {
        $returnType = '\Equisoft\SDK\EquisoftConnect\Model\TasksTask';
        $request = $this->getTaskRequest($taskId, $acceptLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTask'
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTaskRequest($taskId, $acceptLanguage = null, string $contentType = self::contentTypes['getTask'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling getTask'
            );
        }



        $resourcePath = '/crm/api/v1/tasks/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }

        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTaskInternalNoteList
     *
     * Get the internal notes list for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesHistoryType|null $history Query all revisions or not. (optional)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTaskInternalNoteList'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Equisoft\SDK\EquisoftConnect\Model\InternalNotesNoteList|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse
     */
    public function getTaskInternalNoteList($taskId, $history = null, $acceptLanguage = null, string $contentType = self::contentTypes['getTaskInternalNoteList'][0])
    {
        list($response) = $this->getTaskInternalNoteListWithHttpInfo($taskId, $history, $acceptLanguage, $contentType);
        return $response;
    }

    /**
     * Operation getTaskInternalNoteListWithHttpInfo
     *
     * Get the internal notes list for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesHistoryType|null $history Query all revisions or not. (optional)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTaskInternalNoteList'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Equisoft\SDK\EquisoftConnect\Model\InternalNotesNoteList|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaskInternalNoteListWithHttpInfo($taskId, $history = null, $acceptLanguage = null, string $contentType = self::contentTypes['getTaskInternalNoteList'][0])
    {
        $request = $this->getTaskInternalNoteListRequest($taskId, $history, $acceptLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesNoteList',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesNoteList',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesNoteList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTaskInternalNoteListAsync
     *
     * Get the internal notes list for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesHistoryType|null $history Query all revisions or not. (optional)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTaskInternalNoteList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskInternalNoteListAsync($taskId, $history = null, $acceptLanguage = null, string $contentType = self::contentTypes['getTaskInternalNoteList'][0])
    {
        return $this->getTaskInternalNoteListAsyncWithHttpInfo($taskId, $history, $acceptLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskInternalNoteListAsyncWithHttpInfo
     *
     * Get the internal notes list for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesHistoryType|null $history Query all revisions or not. (optional)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTaskInternalNoteList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskInternalNoteListAsyncWithHttpInfo($taskId, $history = null, $acceptLanguage = null, string $contentType = self::contentTypes['getTaskInternalNoteList'][0])
    {
        $returnType = '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesNoteList';
        $request = $this->getTaskInternalNoteListRequest($taskId, $history, $acceptLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTaskInternalNoteList'
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesHistoryType|null $history Query all revisions or not. (optional)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTaskInternalNoteList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTaskInternalNoteListRequest($taskId, $history = null, $acceptLanguage = null, string $contentType = self::contentTypes['getTaskInternalNoteList'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling getTaskInternalNoteList'
            );
        }




        $resourcePath = '/crm/api/v1/tasks/{taskId}/notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $history,
            'history', // param base name
            'InternalNotesHistoryType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }

        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTasks
     *
     * List or search tasks.
     *
     * @param  string|null $ownerId Owner ID filter param. (optional)
     * @param  int[]|null $contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactIds&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
     * @param  \DateTime|null $minDueDate Minimum (inclusive) due date of the task. (optional)
     * @param  \DateTime|null $maxDueDate Maximum (exclusive) due date of the task. (optional)
     * @param  bool|null $isCompleted If true, include only completed tasks. If false, include only TODO tasks. If not set or null, include both. (optional)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksDueDateFilter|null $dueDateFilter Include or exclude tasks with or without due date. (optional)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksOrderByType|null $orderBy Specify the order of the results. (optional)
     * @param  string|null $pageToken Token to specify which page to fetch. (optional)
     * @param  string|null $maxResults Maximum number of records for one result page. If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTasks'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Equisoft\SDK\EquisoftConnect\Model\TasksListTaskResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse
     */
    public function listTasks($ownerId = null, $contactIds = null, $minDueDate = null, $maxDueDate = null, $isCompleted = null, $dueDateFilter = null, $orderBy = null, $pageToken = null, $maxResults = null, $acceptLanguage = null, string $contentType = self::contentTypes['listTasks'][0])
    {
        list($response) = $this->listTasksWithHttpInfo($ownerId, $contactIds, $minDueDate, $maxDueDate, $isCompleted, $dueDateFilter, $orderBy, $pageToken, $maxResults, $acceptLanguage, $contentType);
        return $response;
    }

    /**
     * Operation listTasksWithHttpInfo
     *
     * List or search tasks.
     *
     * @param  string|null $ownerId Owner ID filter param. (optional)
     * @param  int[]|null $contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactIds&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
     * @param  \DateTime|null $minDueDate Minimum (inclusive) due date of the task. (optional)
     * @param  \DateTime|null $maxDueDate Maximum (exclusive) due date of the task. (optional)
     * @param  bool|null $isCompleted If true, include only completed tasks. If false, include only TODO tasks. If not set or null, include both. (optional)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksDueDateFilter|null $dueDateFilter Include or exclude tasks with or without due date. (optional)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksOrderByType|null $orderBy Specify the order of the results. (optional)
     * @param  string|null $pageToken Token to specify which page to fetch. (optional)
     * @param  string|null $maxResults Maximum number of records for one result page. If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTasks'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Equisoft\SDK\EquisoftConnect\Model\TasksListTaskResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTasksWithHttpInfo($ownerId = null, $contactIds = null, $minDueDate = null, $maxDueDate = null, $isCompleted = null, $dueDateFilter = null, $orderBy = null, $pageToken = null, $maxResults = null, $acceptLanguage = null, string $contentType = self::contentTypes['listTasks'][0])
    {
        $request = $this->listTasksRequest($ownerId, $contactIds, $minDueDate, $maxDueDate, $isCompleted, $dueDateFilter, $orderBy, $pageToken, $maxResults, $acceptLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\TasksListTaskResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Equisoft\SDK\EquisoftConnect\Model\TasksListTaskResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\TasksListTaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listTasksAsync
     *
     * List or search tasks.
     *
     * @param  string|null $ownerId Owner ID filter param. (optional)
     * @param  int[]|null $contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactIds&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
     * @param  \DateTime|null $minDueDate Minimum (inclusive) due date of the task. (optional)
     * @param  \DateTime|null $maxDueDate Maximum (exclusive) due date of the task. (optional)
     * @param  bool|null $isCompleted If true, include only completed tasks. If false, include only TODO tasks. If not set or null, include both. (optional)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksDueDateFilter|null $dueDateFilter Include or exclude tasks with or without due date. (optional)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksOrderByType|null $orderBy Specify the order of the results. (optional)
     * @param  string|null $pageToken Token to specify which page to fetch. (optional)
     * @param  string|null $maxResults Maximum number of records for one result page. If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTasksAsync($ownerId = null, $contactIds = null, $minDueDate = null, $maxDueDate = null, $isCompleted = null, $dueDateFilter = null, $orderBy = null, $pageToken = null, $maxResults = null, $acceptLanguage = null, string $contentType = self::contentTypes['listTasks'][0])
    {
        return $this->listTasksAsyncWithHttpInfo($ownerId, $contactIds, $minDueDate, $maxDueDate, $isCompleted, $dueDateFilter, $orderBy, $pageToken, $maxResults, $acceptLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTasksAsyncWithHttpInfo
     *
     * List or search tasks.
     *
     * @param  string|null $ownerId Owner ID filter param. (optional)
     * @param  int[]|null $contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactIds&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
     * @param  \DateTime|null $minDueDate Minimum (inclusive) due date of the task. (optional)
     * @param  \DateTime|null $maxDueDate Maximum (exclusive) due date of the task. (optional)
     * @param  bool|null $isCompleted If true, include only completed tasks. If false, include only TODO tasks. If not set or null, include both. (optional)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksDueDateFilter|null $dueDateFilter Include or exclude tasks with or without due date. (optional)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksOrderByType|null $orderBy Specify the order of the results. (optional)
     * @param  string|null $pageToken Token to specify which page to fetch. (optional)
     * @param  string|null $maxResults Maximum number of records for one result page. If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTasksAsyncWithHttpInfo($ownerId = null, $contactIds = null, $minDueDate = null, $maxDueDate = null, $isCompleted = null, $dueDateFilter = null, $orderBy = null, $pageToken = null, $maxResults = null, $acceptLanguage = null, string $contentType = self::contentTypes['listTasks'][0])
    {
        $returnType = '\Equisoft\SDK\EquisoftConnect\Model\TasksListTaskResponse';
        $request = $this->listTasksRequest($ownerId, $contactIds, $minDueDate, $maxDueDate, $isCompleted, $dueDateFilter, $orderBy, $pageToken, $maxResults, $acceptLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTasks'
     *
     * @param  string|null $ownerId Owner ID filter param. (optional)
     * @param  int[]|null $contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactIds&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
     * @param  \DateTime|null $minDueDate Minimum (inclusive) due date of the task. (optional)
     * @param  \DateTime|null $maxDueDate Maximum (exclusive) due date of the task. (optional)
     * @param  bool|null $isCompleted If true, include only completed tasks. If false, include only TODO tasks. If not set or null, include both. (optional)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksDueDateFilter|null $dueDateFilter Include or exclude tasks with or without due date. (optional)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksOrderByType|null $orderBy Specify the order of the results. (optional)
     * @param  string|null $pageToken Token to specify which page to fetch. (optional)
     * @param  string|null $maxResults Maximum number of records for one result page. If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listTasksRequest($ownerId = null, $contactIds = null, $minDueDate = null, $maxDueDate = null, $isCompleted = null, $dueDateFilter = null, $orderBy = null, $pageToken = null, $maxResults = null, $acceptLanguage = null, string $contentType = self::contentTypes['listTasks'][0])
    {












        $resourcePath = '/crm/api/v1/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ownerId,
            'ownerId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contactIds,
            'contactIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $minDueDate,
            'minDueDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $maxDueDate,
            'maxDueDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isCompleted,
            'isCompleted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dueDateFilter,
            'dueDateFilter', // param base name
            'TasksDueDateFilter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'TasksOrderByType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pageToken,
            'pageToken', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $maxResults,
            'maxResults', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchTask
     *
     * Partially update a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskPayload $tasksPatchTaskPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchTask'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse
     */
    public function patchTask($taskId, $tasksPatchTaskPayload, $acceptLanguage = null, string $contentType = self::contentTypes['patchTask'][0])
    {
        list($response) = $this->patchTaskWithHttpInfo($taskId, $tasksPatchTaskPayload, $acceptLanguage, $contentType);
        return $response;
    }

    /**
     * Operation patchTaskWithHttpInfo
     *
     * Partially update a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskPayload $tasksPatchTaskPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchTask'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchTaskWithHttpInfo($taskId, $tasksPatchTaskPayload, $acceptLanguage = null, string $contentType = self::contentTypes['patchTask'][0])
    {
        $request = $this->patchTaskRequest($taskId, $tasksPatchTaskPayload, $acceptLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation patchTaskAsync
     *
     * Partially update a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskPayload $tasksPatchTaskPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchTaskAsync($taskId, $tasksPatchTaskPayload, $acceptLanguage = null, string $contentType = self::contentTypes['patchTask'][0])
    {
        return $this->patchTaskAsyncWithHttpInfo($taskId, $tasksPatchTaskPayload, $acceptLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchTaskAsyncWithHttpInfo
     *
     * Partially update a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskPayload $tasksPatchTaskPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchTaskAsyncWithHttpInfo($taskId, $tasksPatchTaskPayload, $acceptLanguage = null, string $contentType = self::contentTypes['patchTask'][0])
    {
        $returnType = '\Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskResponse';
        $request = $this->patchTaskRequest($taskId, $tasksPatchTaskPayload, $acceptLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchTask'
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksPatchTaskPayload $tasksPatchTaskPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patchTaskRequest($taskId, $tasksPatchTaskPayload, $acceptLanguage = null, string $contentType = self::contentTypes['patchTask'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling patchTask'
            );
        }

        // verify the required parameter 'tasksPatchTaskPayload' is set
        if ($tasksPatchTaskPayload === null || (is_array($tasksPatchTaskPayload) && count($tasksPatchTaskPayload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tasksPatchTaskPayload when calling patchTask'
            );
        }



        $resourcePath = '/crm/api/v1/tasks/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }

        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tasksPatchTaskPayload)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tasksPatchTaskPayload));
            } else {
                $httpBody = $tasksPatchTaskPayload;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchTaskInternalNote
     *
     * Edit an internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNotePayload $internalNotesPatchNotePayload internalNotesPatchNotePayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNoteResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse
     */
    public function patchTaskInternalNote($taskId, $noteId, $internalNotesPatchNotePayload, $acceptLanguage = null, string $contentType = self::contentTypes['patchTaskInternalNote'][0])
    {
        list($response) = $this->patchTaskInternalNoteWithHttpInfo($taskId, $noteId, $internalNotesPatchNotePayload, $acceptLanguage, $contentType);
        return $response;
    }

    /**
     * Operation patchTaskInternalNoteWithHttpInfo
     *
     * Edit an internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNotePayload $internalNotesPatchNotePayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNoteResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchTaskInternalNoteWithHttpInfo($taskId, $noteId, $internalNotesPatchNotePayload, $acceptLanguage = null, string $contentType = self::contentTypes['patchTaskInternalNote'][0])
    {
        $request = $this->patchTaskInternalNoteRequest($taskId, $noteId, $internalNotesPatchNotePayload, $acceptLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNoteResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNoteResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNoteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation patchTaskInternalNoteAsync
     *
     * Edit an internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNotePayload $internalNotesPatchNotePayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchTaskInternalNoteAsync($taskId, $noteId, $internalNotesPatchNotePayload, $acceptLanguage = null, string $contentType = self::contentTypes['patchTaskInternalNote'][0])
    {
        return $this->patchTaskInternalNoteAsyncWithHttpInfo($taskId, $noteId, $internalNotesPatchNotePayload, $acceptLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchTaskInternalNoteAsyncWithHttpInfo
     *
     * Edit an internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNotePayload $internalNotesPatchNotePayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchTaskInternalNoteAsyncWithHttpInfo($taskId, $noteId, $internalNotesPatchNotePayload, $acceptLanguage = null, string $contentType = self::contentTypes['patchTaskInternalNote'][0])
    {
        $returnType = '\Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNoteResponse';
        $request = $this->patchTaskInternalNoteRequest($taskId, $noteId, $internalNotesPatchNotePayload, $acceptLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchTaskInternalNote'
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\InternalNotesPatchNotePayload $internalNotesPatchNotePayload (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patchTaskInternalNoteRequest($taskId, $noteId, $internalNotesPatchNotePayload, $acceptLanguage = null, string $contentType = self::contentTypes['patchTaskInternalNote'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling patchTaskInternalNote'
            );
        }

        // verify the required parameter 'noteId' is set
        if ($noteId === null || (is_array($noteId) && count($noteId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $noteId when calling patchTaskInternalNote'
            );
        }

        // verify the required parameter 'internalNotesPatchNotePayload' is set
        if ($internalNotesPatchNotePayload === null || (is_array($internalNotesPatchNotePayload) && count($internalNotesPatchNotePayload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internalNotesPatchNotePayload when calling patchTaskInternalNote'
            );
        }



        $resourcePath = '/crm/api/v1/tasks/{taskId}/notes/{noteId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }

        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }
        // path params
        if ($noteId !== null) {
            $resourcePath = str_replace(
                '{' . 'noteId' . '}',
                ObjectSerializer::toPathValue($noteId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($internalNotesPatchNotePayload)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($internalNotesPatchNotePayload));
            } else {
                $httpBody = $internalNotesPatchNotePayload;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTaskLinksDocuments
     *
     * Update the links between a task and existing documents.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksPutTaskLinkDocumentsPayload $tasksPutTaskLinkDocumentsPayload Contains an array of Ids for the documents to link with the task. To remove all links, documentIds set to an empty array  Collections are always overridden if defined. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putTaskLinksDocuments'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTaskLinksDocuments($taskId, $tasksPutTaskLinkDocumentsPayload, $acceptLanguage = null, string $contentType = self::contentTypes['putTaskLinksDocuments'][0])
    {
        $this->putTaskLinksDocumentsWithHttpInfo($taskId, $tasksPutTaskLinkDocumentsPayload, $acceptLanguage, $contentType);
    }

    /**
     * Operation putTaskLinksDocumentsWithHttpInfo
     *
     * Update the links between a task and existing documents.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksPutTaskLinkDocumentsPayload $tasksPutTaskLinkDocumentsPayload Contains an array of Ids for the documents to link with the task. To remove all links, documentIds set to an empty array  Collections are always overridden if defined. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putTaskLinksDocuments'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTaskLinksDocumentsWithHttpInfo($taskId, $tasksPutTaskLinkDocumentsPayload, $acceptLanguage = null, string $contentType = self::contentTypes['putTaskLinksDocuments'][0])
    {
        $request = $this->putTaskLinksDocumentsRequest($taskId, $tasksPutTaskLinkDocumentsPayload, $acceptLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation putTaskLinksDocumentsAsync
     *
     * Update the links between a task and existing documents.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksPutTaskLinkDocumentsPayload $tasksPutTaskLinkDocumentsPayload Contains an array of Ids for the documents to link with the task. To remove all links, documentIds set to an empty array  Collections are always overridden if defined. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putTaskLinksDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTaskLinksDocumentsAsync($taskId, $tasksPutTaskLinkDocumentsPayload, $acceptLanguage = null, string $contentType = self::contentTypes['putTaskLinksDocuments'][0])
    {
        return $this->putTaskLinksDocumentsAsyncWithHttpInfo($taskId, $tasksPutTaskLinkDocumentsPayload, $acceptLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTaskLinksDocumentsAsyncWithHttpInfo
     *
     * Update the links between a task and existing documents.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksPutTaskLinkDocumentsPayload $tasksPutTaskLinkDocumentsPayload Contains an array of Ids for the documents to link with the task. To remove all links, documentIds set to an empty array  Collections are always overridden if defined. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putTaskLinksDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTaskLinksDocumentsAsyncWithHttpInfo($taskId, $tasksPutTaskLinkDocumentsPayload, $acceptLanguage = null, string $contentType = self::contentTypes['putTaskLinksDocuments'][0])
    {
        $returnType = '';
        $request = $this->putTaskLinksDocumentsRequest($taskId, $tasksPutTaskLinkDocumentsPayload, $acceptLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTaskLinksDocuments'
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  \Equisoft\SDK\EquisoftConnect\Model\TasksPutTaskLinkDocumentsPayload $tasksPutTaskLinkDocumentsPayload Contains an array of Ids for the documents to link with the task. To remove all links, documentIds set to an empty array  Collections are always overridden if defined. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putTaskLinksDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putTaskLinksDocumentsRequest($taskId, $tasksPutTaskLinkDocumentsPayload, $acceptLanguage = null, string $contentType = self::contentTypes['putTaskLinksDocuments'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling putTaskLinksDocuments'
            );
        }

        // verify the required parameter 'tasksPutTaskLinkDocumentsPayload' is set
        if ($tasksPutTaskLinkDocumentsPayload === null || (is_array($tasksPutTaskLinkDocumentsPayload) && count($tasksPutTaskLinkDocumentsPayload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tasksPutTaskLinkDocumentsPayload when calling putTaskLinksDocuments'
            );
        }



        $resourcePath = '/crm/api/v1/tasks/{taskId}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }

        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tasksPutTaskLinkDocumentsPayload)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tasksPutTaskLinkDocumentsPayload));
            } else {
                $httpBody = $tasksPutTaskLinkDocumentsPayload;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restoreTaskInternalNote
     *
     * Restore an archived internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restoreTaskInternalNote($taskId, $noteId, $acceptLanguage = null, string $contentType = self::contentTypes['restoreTaskInternalNote'][0])
    {
        $this->restoreTaskInternalNoteWithHttpInfo($taskId, $noteId, $acceptLanguage, $contentType);
    }

    /**
     * Operation restoreTaskInternalNoteWithHttpInfo
     *
     * Restore an archived internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restoreTaskInternalNoteWithHttpInfo($taskId, $noteId, $acceptLanguage = null, string $contentType = self::contentTypes['restoreTaskInternalNote'][0])
    {
        $request = $this->restoreTaskInternalNoteRequest($taskId, $noteId, $acceptLanguage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation restoreTaskInternalNoteAsync
     *
     * Restore an archived internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreTaskInternalNoteAsync($taskId, $noteId, $acceptLanguage = null, string $contentType = self::contentTypes['restoreTaskInternalNote'][0])
    {
        return $this->restoreTaskInternalNoteAsyncWithHttpInfo($taskId, $noteId, $acceptLanguage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restoreTaskInternalNoteAsyncWithHttpInfo
     *
     * Restore an archived internal note for a task.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreTaskInternalNoteAsyncWithHttpInfo($taskId, $noteId, $acceptLanguage = null, string $contentType = self::contentTypes['restoreTaskInternalNote'][0])
    {
        $returnType = '';
        $request = $this->restoreTaskInternalNoteRequest($taskId, $noteId, $acceptLanguage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restoreTaskInternalNote'
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  int $noteId Note unique identifier. (required)
     * @param  string|null $acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreTaskInternalNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restoreTaskInternalNoteRequest($taskId, $noteId, $acceptLanguage = null, string $contentType = self::contentTypes['restoreTaskInternalNote'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling restoreTaskInternalNote'
            );
        }

        // verify the required parameter 'noteId' is set
        if ($noteId === null || (is_array($noteId) && count($noteId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $noteId when calling restoreTaskInternalNote'
            );
        }



        $resourcePath = '/crm/api/v1/tasks/{taskId}/notes/{noteId}/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }

        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }
        // path params
        if ($noteId !== null) {
            $resourcePath = str_replace(
                '{' . 'noteId' . '}',
                ObjectSerializer::toPathValue($noteId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transferTaskToCompleted
     *
     * Transfer a task to completed/done.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferTaskToCompleted'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Equisoft\SDK\EquisoftConnect\Model\TasksTransferToCompletedResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse
     */
    public function transferTaskToCompleted($taskId, string $contentType = self::contentTypes['transferTaskToCompleted'][0])
    {
        list($response) = $this->transferTaskToCompletedWithHttpInfo($taskId, $contentType);
        return $response;
    }

    /**
     * Operation transferTaskToCompletedWithHttpInfo
     *
     * Transfer a task to completed/done.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferTaskToCompleted'] to see the possible values for this operation
     *
     * @throws \Equisoft\SDK\EquisoftConnect\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Equisoft\SDK\EquisoftConnect\Model\TasksTransferToCompletedResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse|\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function transferTaskToCompletedWithHttpInfo($taskId, string $contentType = self::contentTypes['transferTaskToCompleted'][0])
    {
        $request = $this->transferTaskToCompletedRequest($taskId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\TasksTransferToCompletedResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Equisoft\SDK\EquisoftConnect\Model\TasksTransferToCompletedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\TasksTransferToCompletedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Equisoft\SDK\EquisoftConnect\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation transferTaskToCompletedAsync
     *
     * Transfer a task to completed/done.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferTaskToCompleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferTaskToCompletedAsync($taskId, string $contentType = self::contentTypes['transferTaskToCompleted'][0])
    {
        return $this->transferTaskToCompletedAsyncWithHttpInfo($taskId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transferTaskToCompletedAsyncWithHttpInfo
     *
     * Transfer a task to completed/done.
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferTaskToCompleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferTaskToCompletedAsyncWithHttpInfo($taskId, string $contentType = self::contentTypes['transferTaskToCompleted'][0])
    {
        $returnType = '\Equisoft\SDK\EquisoftConnect\Model\TasksTransferToCompletedResponse';
        $request = $this->transferTaskToCompletedRequest($taskId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transferTaskToCompleted'
     *
     * @param  string $taskId Task unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferTaskToCompleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transferTaskToCompletedRequest($taskId, string $contentType = self::contentTypes['transferTaskToCompleted'][0])
    {

        // verify the required parameter 'taskId' is set
        if ($taskId === null || (is_array($taskId) && count($taskId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskId when calling transferTaskToCompleted'
            );
        }


        $resourcePath = '/crm/api/v1/tasks/{taskId}/transferToCompleted';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($taskId !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($taskId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        if (is_string($formParamValueItem)) {
                            // JSON part
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem,
                                'headers' => [
                                    'Content-Disposition' => "form-data; name=\"$formParamName\"; filename=\"$formParamName.json\"",
                                    'Content-Type' => 'application/json; charset=UTF-8'
                                ]
                            ];
                        } else {
                            $multipartContents[] = [
                                'name' => $formParamName,
                                'contents' => $formParamValueItem
                            ];
                        }
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
